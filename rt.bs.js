// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Js_promise2 from "rescript/lib/es6/js_promise2.js";

function make(x, y, z) {
  return {
          x: x,
          y: y,
          z: z
        };
}

function times(v, k) {
  return {
          x: v.x * k,
          y: v.y * k,
          z: v.z * k
        };
}

function minus(v1, v2) {
  return {
          x: v1.x - v2.x,
          y: v1.y - v2.y,
          z: v1.z - v2.z
        };
}

function plus(v1, v2) {
  return {
          x: v1.x + v2.x,
          y: v1.y + v2.y,
          z: v1.z + v2.z
        };
}

function dot(v1, v2) {
  return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
}

function mag(param) {
  var z = param.z;
  var y = param.y;
  var x = param.x;
  return Math.sqrt(x * x + y * y + z * z);
}

function norm(v) {
  var mag$1 = mag(v);
  var div = mag$1 === 0.0 ? Pervasives.infinity : 1.0 / mag$1;
  return times(v, div);
}

function cross(v1, v2) {
  return {
          x: v1.y * v2.z - v1.z * v2.y,
          y: v1.z * v2.x - v1.x * v2.z,
          z: v1.x * v2.y - v1.y * v2.x
        };
}

var Vector = {
  make: make,
  times: times,
  minus: minus,
  plus: plus,
  dot: dot,
  mag: mag,
  norm: norm,
  cross: cross
};

function make$1(r, g, b) {
  return {
          r: r,
          g: g,
          b: b
        };
}

function scale(v, k) {
  return {
          r: v.r * k,
          g: v.g * k,
          b: v.b * k
        };
}

function plus$1(v1, v2) {
  return {
          r: v1.r + v2.r,
          g: v1.g + v2.g,
          b: v1.b + v2.b
        };
}

function times$1(v1, v2) {
  return {
          r: v1.r * v2.r,
          g: v1.g * v2.g,
          b: v1.b * v2.b
        };
}

var white = {
  r: 1.0,
  g: 1.0,
  b: 1.0
};

var grey = {
  r: 0.5,
  g: 0.5,
  b: 0.5
};

var black = {
  r: 0.0,
  g: 0.0,
  b: 0.0
};

function toDrawingColor(c) {
  return {
          r: Math.floor(Math.min(c.r, 1.0) * 255.0),
          g: Math.floor(Math.min(c.g, 1.0) * 255.0),
          b: Math.floor(Math.min(c.b, 1.0) * 255.0)
        };
}

var Color = {
  make: make$1,
  scale: scale,
  plus: plus$1,
  times: times$1,
  white: white,
  grey: grey,
  black: black,
  background: black,
  defaultColor: black,
  toDrawingColor: toDrawingColor
};

function make$2(pos, lookAt) {
  var down = {
    x: 0.0,
    y: -1.0,
    z: 0.0
  };
  var forward = norm(minus(lookAt, pos));
  var right = times(norm(cross(forward, down)), 1.5);
  var up = times(norm(cross(forward, right)), 1.5);
  return {
          pos: pos,
          forward: forward,
          right: right,
          up: up
        };
}

var Camera = {
  make: make$2
};

function shiny_diffuse(_pos) {
  return white;
}

function shiny_specular(_pos) {
  return grey;
}

function shiny_reflect(_pos) {
  return 0.7;
}

var shiny = {
  diffuse: shiny_diffuse,
  specular: shiny_specular,
  reflect: shiny_reflect,
  roughness: 250.0
};

function checkerboard_diffuse(param) {
  var match = ((Math.floor(param.z) | 0) + (Math.floor(param.x) | 0) | 0) % 2;
  if (match !== 0) {
    return white;
  } else {
    return black;
  }
}

function checkerboard_specular(_pos) {
  return white;
}

function checkerboard_reflect(param) {
  var match = ((Math.floor(param.z) | 0) + (Math.floor(param.x) | 0) | 0) % 2;
  if (match !== 0) {
    return 0.1;
  } else {
    return 0.7;
  }
}

var checkerboard = {
  diffuse: checkerboard_diffuse,
  specular: checkerboard_specular,
  reflect: checkerboard_reflect,
  roughness: 150.0
};

var Surface = {
  shiny: shiny,
  checkerboard: checkerboard
};

function makeSphere(center, radius, surface) {
  return {
          TAG: /* Sphere */0,
          center: center,
          radius2: radius * radius,
          surface: surface
        };
}

function makePlane(normal, offset, surface) {
  return {
          TAG: /* Plane */1,
          normal: normal,
          offset: offset,
          surface: surface
        };
}

function surface(thing) {
  return thing.surface;
}

function normal(thing, pos) {
  if (thing.TAG === /* Sphere */0) {
    return norm(minus(pos, thing.center));
  } else {
    return thing.normal;
  }
}

function intersect(thing, ray) {
  if (thing.TAG === /* Sphere */0) {
    var eo = minus(thing.center, ray.start);
    var v = dot(eo, ray.dir);
    if (v < 0.0) {
      return ;
    }
    var disc = thing.radius2 - (dot(eo, eo) - v * v);
    if (disc >= 0.0) {
      return {
              thing: thing,
              ray: ray,
              dist: v - Math.sqrt(disc)
            };
    } else {
      return ;
    }
  }
  var normal = thing.normal;
  var denom = dot(normal, ray.dir);
  if (denom > 0.0) {
    return ;
  } else {
    return {
            thing: thing,
            ray: ray,
            dist: (dot(normal, ray.start) + thing.offset) / - denom
          };
  }
}

var Thing = {
  makeSphere: makeSphere,
  makePlane: makePlane,
  surface: surface,
  normal: normal,
  intersect: intersect
};

var default_things = [
  {
    TAG: /* Plane */1,
    normal: {
      x: 0.0,
      y: 1.0,
      z: 0.0
    },
    offset: 0.0,
    surface: checkerboard
  },
  makeSphere({
        x: 0.0,
        y: 1.0,
        z: -0.25
      }, 1.0, shiny),
  makeSphere({
        x: -1.0,
        y: 0.5,
        z: 1.5
      }, 0.5, shiny)
];

var default_lights = [
  {
    pos: {
      x: -2.0,
      y: 2.5,
      z: 0.0
    },
    color: {
      r: 0.49,
      g: 0.07,
      b: 0.07
    }
  },
  {
    pos: {
      x: 1.5,
      y: 2.5,
      z: 1.5
    },
    color: {
      r: 0.07,
      g: 0.07,
      b: 0.49
    }
  },
  {
    pos: {
      x: 1.5,
      y: 2.5,
      z: -1.5
    },
    color: {
      r: 0.07,
      g: 0.49,
      b: 0.071
    }
  },
  {
    pos: {
      x: 0.0,
      y: 3.5,
      z: 0.0
    },
    color: {
      r: 0.21,
      g: 0.21,
      b: 0.35
    }
  }
];

var default_camera = make$2({
      x: 3.0,
      y: 2.0,
      z: 4.0
    }, {
      x: -1.0,
      y: 0.5,
      z: 0.0
    });

var $$default = {
  things: default_things,
  lights: default_lights,
  camera: default_camera
};

var Scene = {
  $$default: $$default
};

function intersections(ray, scene) {
  var closest = Pervasives.infinity;
  var closestInter;
  var len = scene.things.length;
  for(var i = 0; i < len; ++i){
    var thing = scene.things[i];
    var inter = intersect(thing, ray);
    if (inter !== undefined && inter.dist < closest) {
      closestInter = inter;
      closest = inter.dist;
    }
    
  }
  return closestInter;
}

function testRay(ray, scene) {
  var match = intersections(ray, scene);
  if (match !== undefined) {
    return match.dist;
  }
  
}

function traceRay(ray, scene, depth) {
  var intersection = intersections(ray, scene);
  if (intersection !== undefined) {
    return shade(intersection, scene, depth);
  } else {
    return black;
  }
}

function getReflectionColor(thing, pos, rd, scene, depth) {
  var surface = thing.surface;
  return scale(traceRay({
                  start: pos,
                  dir: rd
                }, scene, depth + 1 | 0), surface.reflect(pos));
}

function getNaturalColor(thing, pos, normal, rd, scene) {
  var surface = thing.surface;
  return Belt_Array.reduce(scene.lights, black, (function (color, light) {
                var ldis = minus(light.pos, pos);
                var livec = norm(ldis);
                var neatIsect = testRay({
                      start: pos,
                      dir: livec
                    }, scene);
                if (neatIsect !== undefined && neatIsect <= mag(ldis)) {
                  return color;
                }
                var illum = dot(livec, normal);
                var lcolor = illum > 0.0 ? scale(light.color, illum) : black;
                var specular = dot(livec, norm(rd));
                var scolor = specular > 0.0 ? scale(light.color, Math.pow(specular, surface.roughness)) : black;
                return plus$1(color, plus$1(times$1(lcolor, surface.diffuse(pos)), times$1(scolor, surface.specular(pos))));
              }));
}

function shade(intersection, scene, depth) {
  var match = intersection.ray;
  var dir = match.dir;
  var thing = intersection.thing;
  var pos = plus(times(dir, intersection.dist), match.start);
  var normal$1 = normal(thing, pos);
  var target = times(times(normal$1, dot(normal$1, dir)), 2.0);
  var rd = minus(dir, target);
  var naturalColor = plus$1(black, getNaturalColor(thing, pos, normal$1, rd, scene));
  var reflectedColor = depth >= 5 ? grey : getReflectionColor(thing, pos, rd, scene, depth);
  return plus$1(naturalColor, reflectedColor);
}

function render(ctx, scene, screenWidth, screenHeight) {
  var recenterX = function (x) {
    return (x - screenWidth / 2.0) / 2.0 / screenWidth;
  };
  var recenterY = function (y) {
    return - (y - screenHeight / 2.0) / 2.0 / screenHeight;
  };
  var getPoint = function (x, y, camera) {
    return norm(plus(camera.forward, plus(times(camera.right, recenterX(x)), times(camera.up, recenterY(y)))));
  };
  var camera = scene.camera;
  for(var y = 0; y < screenHeight; ++y){
    for(var x = 0; x < screenWidth; ++x){
      var match = toDrawingColor(traceRay({
                start: camera.pos,
                dir: getPoint(x, y, camera)
              }, scene, 0));
      ctx.fillStyle = "rgb(" + String(match.r) + ", " + String(match.g) + ", " + String(match.b) + ")";
      ctx.fillRect(x, y, 1, 1);
    }
  }
}

var RayTracer = {
  maxDepth: 5,
  intersections: intersections,
  testRay: testRay,
  traceRay: traceRay,
  getReflectionColor: getReflectionColor,
  getNaturalColor: getNaturalColor,
  shade: shade,
  render: render
};

function exec(width, height) {
  var canv = document.createElement("canvas");
  canv.setAttribute("width", String(width));
  canv.setAttribute("height", String(height));
  render(canv.getContext("2d"), $$default, width, height);
  document.body.appendChild(canv);
}

function render$1(param) {
  return new Promise((function (resolve, param) {
                requestAnimationFrame(function (param) {
                      console.time("raytrace ReScript");
                      exec(256, 256);
                      console.timeEnd("raytrace ReScript");
                      resolve(undefined);
                    });
              }));
}

Js_promise2.then(Js_promise2.then(Js_promise2.then(Js_promise2.then(Js_promise2.then(Js_promise2.then(render$1(undefined), render$1), render$1), render$1), render$1), render$1), (function (param) {
        document.documentElement.classList.add("done");
        return Promise.resolve(undefined);
      }));

var size = 256;

export {
  Vector ,
  Color ,
  Camera ,
  Surface ,
  Thing ,
  Scene ,
  RayTracer ,
  exec ,
  size ,
  render$1 as render,
}
/* default Not a pure module */
